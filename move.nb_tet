src/parsing/parsing2.c:	if (game->key.size_height > 50
src/parsing/parsing2.c:	|| game->key.size_width > 50) // i have to change value
src/display_tetrominos.c:			set_color(game->win.win, game_map->tab[i][j].color) : 0;
src/display_tetrominos.c:			mvwprintw(game->win.win, j + 1, i + 1, "%c", game_map->tab[i][j]) : 0;
src/display_tetrominos.c:			wattroff(game->win.win, COLOR_PAIR(1)) : 0;
src/display_tetrominos.c:	for (int i = 0; i < cp_tetr[game->move.nb_tet].y; i++)
src/display_tetrominos.c:		for (int j = 0; j < cp_tetr[game->move.nb_tet].x; j++)
src/display_tetrominos.c:			cp_tetr[game->move.nb_tet].item[i][j] == '*' ? mvwprintw(game->win.win, cp_tetr[game->move.nb_tet].coord_y + i + 1, cp_tetr[game->move.nb_tet].coord_x + j + 1, "%c", cp_tetr[game->move.nb_tet].item[i][j]) : 0;
src/move_tetro.c:	if (clock() > clk_start + temp * (9 - game->key.level)) {
src/move_tetro.c:		cp_tetr[game->move.nb_tet].coord_y++;
src/move_tetro.c:	werase(game->win.win);
src/move_tetro.c:	&& cp_tetr[game->move.nb_tet].coord_y == 1) {
src/move_tetro.c:	} if (C_Y >= WIN_HEIGHT - cp_tetr[game->move.nb_tet].y
src/move_tetro.c:		cp_tetr[game->move.nb_tet] = game->tetrominos[game->move.nb_tet];
src/move_tetro.c:		game->move.nb_tet = game->rand_next;
src/move_tetro.c:		for (int i = 0; i < cp_tetr[game->move.nb_tet].y; i++)
src/move_tetro.c:			for (int j = 0; cp_tetr[game->move.nb_tet].item[i][j] != '\0'; j++) {
src/move_tetro.c:				if (cp_tetr[game->move.nb_tet].y + k >= (int)game_map->nb_case_y
src/move_tetro.c:					&& cp_tetr[game->move.nb_tet].item[i][j] == '*')) {
src/move_tetro.c:	if (C_X >= WIN_WIDTH - cp_tetr[game->move.nb_tet].x
src/move_tetro.c:		C_X = WIN_WIDTH - cp_tetr[game->move.nb_tet].x;
src/move_tetro.c:	werase(game->win.win);
src/move_tetro.c:	werase(game->win.win);
src/next.c:	wclear(game->win.next_i);
src/next.c:	game->rand_next == game->move.nb_tet ? game->rand_next = 2 : 0;
src/next.c:	mvwprintw(game->win.next_i, 0, 5, "<Next>");
src/next.c:	set_color(game->win.next_i, game->tetrominos[game->rand_next].color);
src/next.c:	for (int i = 0; i < game->tetrominos[game->rand_next].y; i++) {
src/next.c:		mvwprintw(game->win.next_i, 10 / 2 - game->tetrominos[game->rand_next].y / 2 + i,
src/next.c:			20 / 2 - (game->tetrominos[game->rand_next].x / 2), game->tetrominos[game->rand_next].item[i]);
src/next.c:	wattroff(game->win.next_i, COLOR_PAIR(game->tetrominos[game->rand_next].color));
src/pause.c:		if (read(0, key, 3) == 1 && key[0] == game->key.key_pause) {
src/pause.c:	if (key[0] == game->key.key_pause) {
src/colisions.c:	for (int i = 0; i < cp_tetr[game->move.nb_tet].y; i++)
src/colisions.c:		for (int j = 0; cp_tetr[game->move.nb_tet].item[i][j] != '\0'; j++) {
src/colisions.c:			&& cp_tetr[game->move.nb_tet].item[i][j] == '*')
src/colisions.c:			&& cp_tetr[game->move.nb_tet].item[i][j] == '*')
src/colisions.c:	for (int i = 0; i < cp_tetr[game->move.nb_tet].y; i++)
src/colisions.c:		for (int j = 0; cp_tetr[game->move.nb_tet].item[i][j] != '\0'; j++) {
src/colisions.c:			&& cp_tetr[game->move.nb_tet].item[i][j] == '*')
src/windows.c:	game->move.nb_tet == game->rand_next
src/windows.c:		? game->rand_next = create_next() : 0;
src/windows.c:	game->key.next == true ? display_next(game) : 0;
src/windows.c:	game->key.next == true ? BORDER_WIN_NEXT : 0;
src/windows.c:	wrefresh(game->win.title);
src/windows.c:	wrefresh(game->win.score);
src/windows.c:	game->key.next == true ? wrefresh(game->win.next_i) : 0;
src/windows.c:	wrefresh(game->win.win);
src/windows.c:	game->win.win = newwin(WIN_HEIGHT + 2, WIN_WIDTH + 2,
src/windows.c:	game->win.score = newwin(20, 10 + (COLS / 4), LINES / 2, 0);
src/windows.c:	game->key.next == true ?
src/windows.c:		game->win.next_i = newwin(10, 20, 0, COLS - WIN_HEIGHT) : 0;
src/windows.c:	game->win.title = newwin(15, 50, 0, 0);
src/exit.c:	if (read(0, key, 3) == 1 && key[0] == game->key.key_quit) {
src/exit.c:		delwin(game->win.win);
src/exit.c:		delwin(game->win.score);
src/exit.c:		delwin(game->win.title);
src/title.c:	time(NULL) != clk || !(rand() % 500) ? set_color(game->win.title, j) : 0;
src/title.c:		mvwprintw(game->win.title, 15 / 2 - count_row_map("titre") / 2 + i,
src/title.c:	//wattroff(game->win.title, COLOR_PAIR(1));
src/command.c:	if (my_strncmp(key, game->key.key_turn, 3) == 0
src/command.c:	&& C_X + cp_tetr[game->move.nb_tet].y <= WIN_WIDTH - 1)
src/command.c:		cp_tetr[game->move.nb_tet] = rotate(&cp_tetr[ID]);
src/command.c:	if (my_strncmp(key, game->key.key_drop, 3) == 0)
src/command.c:	if (my_strncmp(key, game->key.ke_left, 3) == 0)
src/command.c:	if (my_strncmp(key, game->key.ke_right, 3) == 0)
src/game_over.c:	game->win.game_over =  newwin(20, 10 + (COLS / 4), 0, 0);
src/game_over.c:	wborder(game->win.game_over, '|', '|', '-', '-', '/', '\\', '\\', '/');
src/game_over.c:	wrefresh(game->win.game_over);
src/game_over.c:	mvwprintw(game->win.game_over, 2, 1, "High Score:\t%d",
src/game_over.c:	mvwprintw(game->win.game_over, 4, 1, "Score:\t%d", game->score);
src/game_over.c:	mvwprintw(game->win.game_over, 10, 1, "Level:\t%d",
src/game_over.c:		game->key.level);
src/game_over.c:	mvwprintw(game->win.game_over, 14, 1, "Timer:\t%.2d:%.2d", game->time);
src/game_over.c:	wrefresh(game->win.game_over);
src/game_over.c:		if (read(0, key, 3) == 1 && key[0] == game->key.key_quit) {
src/game_over.c:			delwin(game->win.win);
src/game_over.c:			delwin(game->win.score);
src/game_over.c:			delwin(game->win.title);
src/game_over.c:			delwin(game->win.game_over);
src/insert_in_to_map.c:	for (int i = 0; i < cp_tetr[game->move.nb_tet].y; i++)
src/insert_in_to_map.c:		for (int j = 0; cp_tetr[game->move.nb_tet].item[i][j] != '\0'; j++) {
src/insert_in_to_map.c:			cp_tetr[game->move.nb_tet].item[i][j] == '*' ?	game_map->tab[j + C_X][i + C_Y].type = cp_tetr[game->move.nb_tet].item[i][j] : 0;
src/insert_in_to_map.c:			game_map->tab[j + C_X][i + C_Y].color = cp_tetr[game->move.nb_tet].color;
src/score.c:	game->score += 10;
src/score.c:	game->score >= 200 && check_level++ == 10 ? game->key.level += '1' : 0;
src/score.c:	game->score >= 200 && check_level++ == 10 ? check_level = 0 : 0;
src/score.c:	write(fd, inttostr(game->score), my_strlen(inttostr(game->score)));
src/score.c:	if (game->score > my_atoi(display_high_score())) {
src/score.c:		mvwprintw(game->win.game_over, 1, 1, "NEW SCORE!!\n");
src/score.c:		return (game->score);
src/score.c:	mvwprintw(game->win.score, 0, 10, "SCOREBOARD");
src/score.c:	mvwprintw(game->win.score, 2, 1, "High Score:\t%s",
src/score.c:	mvwprintw(game->win.score, 4, 1, "Score:\t%d", game->score);
src/score.c:	mvwprintw(game->win.score, 8, 1, "Lines:\t%d", 1);
src/score.c:	mvwprintw(game->win.score, 10, 1, "Level:\t%d", game->key.level);
src/score.c:	mvwprintw(game->win.score, 14, 1, "Timer:\t%.2d:%.2d",
src/score.c:		game->time = (clk - clk_start) / 60, (clk - clk_start)% 60);
src/main.c:		set_color(game->win.win, game->tetrominos[ID].color);
src/main.c:		wattroff(game->win.win, COLOR_PAIR(1));
include/macros.h:#define BORDER_WIN_WIN wborder(game->win.win, '|', '|', '-', '-', '+', \
include/macros.h:#define BORDER_WIN_SCORE wborder(game->win.score, '|', '|', '-', '-', \
include/macros.h:#define BORDER_WIN_NEXT wborder(game->win.next_i, '|', '|', '-', '-', '/', \
include/macros.h:#define BORDER_WIN_TITLE wborder(game->win.title, '|', '|', '-', '-', '/', \
include/macros.h:#define ID game->move.nb_tet
include/macros.h:#define C_X cp_tetr[game->move.nb_tet].coord_x
include/macros.h:#define C_Y cp_tetr[game->move.nb_tet].coord_y
include/macros.h:#define WIN_WIDTH game->key.size_width
include/macros.h:#define WIN_HEIGHT game->key.size_height
